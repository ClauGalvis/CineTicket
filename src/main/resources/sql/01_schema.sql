-- =========================================================
-- CineTicket - 01_schema.sql (PostgreSQL 12+)
-- Crea extensiones, tipos ENUM, tablas, constraints, índices y triggers
-- =========================================================

BEGIN;

-- (Opcional) Usar un esquema dedicado:
-- CREATE SCHEMA IF NOT EXISTS cineticket;
-- SET search_path TO cineticket, public;

-- ============ Extensiones ============
CREATE EXTENSION IF NOT EXISTS citext;      -- unicidad case-insensitive
CREATE EXTENSION IF NOT EXISTS btree_gist;  -- para EXCLUDE con rangos

-- ============ Tipos ENUM ============
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname='rol') THEN
    CREATE TYPE rol AS ENUM ('ADMIN','USUARIO');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname='metodo_pago') THEN
    CREATE TYPE metodo_pago AS ENUM ('PSE','TRANSFERENCIA');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname='estado_compra') THEN
    CREATE TYPE estado_compra AS ENUM ('CONFIRMADA','CANCELADA');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname='estado_entrada') THEN
    CREATE TYPE estado_entrada AS ENUM ('ACTIVA','UTILIZADA','CANCELADA');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname='tipo_asiento') THEN
    CREATE TYPE tipo_asiento AS ENUM ('REGULAR','VIP','PREFERENCIAL');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname='clasificacion') THEN
    CREATE TYPE clasificacion AS ENUM ('T','7+','12+','15+','18+');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname='estado_funcion') THEN
    CREATE TYPE estado_funcion AS ENUM ('PROGRAMADA','EN_CURSO','FINALIZADA','CANCELADA');
  END IF;
END$$;

-- ============ Tablas ============

-- USUARIO
CREATE TABLE IF NOT EXISTS usuario (
  id_usuario         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_completo    VARCHAR(100) NOT NULL,
  correo_electronico CITEXT       NOT NULL UNIQUE,
  nombre_usuario     CITEXT       NOT NULL UNIQUE,
  contrasena_hash    VARCHAR(60)  NOT NULL,
  rol                rol          NOT NULL,
  fecha_registro     TIMESTAMP    NOT NULL DEFAULT now(),
  activo             BOOLEAN      NOT NULL DEFAULT TRUE
);

-- GENERO
CREATE TABLE IF NOT EXISTS genero (
  id_genero     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_genero VARCHAR(50) NOT NULL UNIQUE,
  descripcion   VARCHAR(150),
  activo        BOOLEAN     NOT NULL DEFAULT TRUE
);

-- PELICULA
CREATE TABLE IF NOT EXISTS pelicula (
  id_pelicula       INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  titulo            VARCHAR(200)  NOT NULL,
  duracion_minutos  INTEGER       NOT NULL CHECK (duracion_minutos > 0),
  clasificacion     clasificacion NOT NULL,
  sinopsis          TEXT,
  imagen_url        VARCHAR(255),
  fecha_estreno     DATE,
  activa            BOOLEAN       NOT NULL DEFAULT TRUE
);

-- PELICULA_GENERO (N:M)
CREATE TABLE IF NOT EXISTS pelicula_genero (
  pelicula_id INTEGER NOT NULL REFERENCES pelicula(id_pelicula) ON DELETE CASCADE,
  genero_id   INTEGER NOT NULL REFERENCES genero(id_genero)     ON DELETE RESTRICT,
  PRIMARY KEY (pelicula_id, genero_id)
);

-- SALA
CREATE TABLE IF NOT EXISTS sala (
  id_sala          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_sala      VARCHAR(50) NOT NULL UNIQUE,
  capacidad_total  INTEGER     NOT NULL CHECK (capacidad_total > 0),
  filas            INTEGER     NOT NULL CHECK (filas > 0),
  columnas         INTEGER     NOT NULL CHECK (columnas > 0),
  activa           BOOLEAN     NOT NULL DEFAULT TRUE,
  CONSTRAINT chk_capacidad_consistente CHECK (capacidad_total = filas * columnas)
);

-- ASIENTO
CREATE TABLE IF NOT EXISTS asiento (
  id_asiento    INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sala_id       INTEGER      NOT NULL REFERENCES sala(id_sala) ON DELETE RESTRICT,
  fila          VARCHAR(5)   NOT NULL,
  numero        INTEGER      NOT NULL CHECK (numero > 0),
  tipo_asiento  tipo_asiento NOT NULL DEFAULT 'REGULAR',
  activo        BOOLEAN      NOT NULL DEFAULT TRUE,
  CONSTRAINT uniq_asiento_sala UNIQUE (sala_id, fila, numero)
);

-- FUNCION
CREATE TABLE IF NOT EXISTS funcion (
  id_funcion         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  pelicula_id        INTEGER        NOT NULL REFERENCES pelicula(id_pelicula) ON DELETE RESTRICT,
  sala_id            INTEGER        NOT NULL REFERENCES sala(id_sala)         ON DELETE RESTRICT,
  fecha_hora_inicio  TIMESTAMP      NOT NULL,
  fecha_hora_fin     TIMESTAMP      NOT NULL,
  precio_entrada     NUMERIC(10,2)  NOT NULL CHECK (precio_entrada >= 0),
  estado             estado_funcion NOT NULL DEFAULT 'PROGRAMADA',
  CHECK (fecha_hora_fin > fecha_hora_inicio)
);

-- Evitar solape de funciones en misma sala: EXCLUDE por rango [inicio, fin)
CREATE INDEX IF NOT EXISTS idx_funcion_rango
  ON funcion USING gist (sala_id, tsrange(fecha_hora_inicio, fecha_hora_fin, '[)'));
ALTER TABLE funcion
  ADD CONSTRAINT excl_funcion_sala_horario
  EXCLUDE USING gist (
    sala_id WITH =,
    tsrange(fecha_hora_inicio, fecha_hora_fin, '[)') WITH &&
  ) WHERE (estado <> 'CANCELADA');

-- COMPRA
CREATE TABLE IF NOT EXISTS compra (
  id_compra           INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  usuario_id          INTEGER       NOT NULL REFERENCES usuario(id_usuario) ON DELETE RESTRICT,
  fecha_hora_compra   TIMESTAMP     NOT NULL DEFAULT now(),
  total_entradas      NUMERIC(10,2) NOT NULL CHECK (total_entradas   >= 0),
  total_confiteria    NUMERIC(10,2) NOT NULL CHECK (total_confiteria >= 0),
  total_general       NUMERIC(10,2) GENERATED ALWAYS AS (total_entradas + total_confiteria) STORED,
  metodo_pago         metodo_pago   NOT NULL,
  estado_compra       estado_compra NOT NULL DEFAULT 'CONFIRMADA',
  fecha_cancelacion   TIMESTAMP,
  ruta_comprobante_pdf VARCHAR(255),
  CHECK (
    (estado_compra = 'CANCELADA'  AND fecha_cancelacion IS NOT NULL) OR
    (estado_compra = 'CONFIRMADA' AND fecha_cancelacion IS NULL)
  )
);

-- ENTRADA
CREATE TABLE IF NOT EXISTS entrada (
  id_entrada      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  compra_id       INTEGER       NOT NULL REFERENCES compra(id_compra)   ON DELETE CASCADE,
  funcion_id      INTEGER       NOT NULL REFERENCES funcion(id_funcion) ON DELETE RESTRICT,
  asiento_id      INTEGER       NOT NULL REFERENCES asiento(id_asiento) ON DELETE RESTRICT,
  precio_unitario NUMERIC(10,2) NOT NULL CHECK (precio_unitario >= 0),
  estado_entrada  estado_entrada NOT NULL DEFAULT 'ACTIVA'
);
-- Evitar doble venta: asiento único ACTIVO por función
CREATE UNIQUE INDEX IF NOT EXISTS uniq_entrada_funcion_asiento_activa
  ON entrada (funcion_id, asiento_id) WHERE (estado_entrada = 'ACTIVA');

-- COMBO_CONFITERIA
CREATE TABLE IF NOT EXISTS combo_confiteria (
  id_combo      INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nombre_combo  VARCHAR(100) NOT NULL UNIQUE,
  descripcion   TEXT,
  precio        NUMERIC(10,2) NOT NULL CHECK (precio >= 0),
  imagen_url    VARCHAR(255),
  disponible    BOOLEAN       NOT NULL DEFAULT TRUE,
  categoria     VARCHAR(30)
);

-- COMPRA_CONFITERIA
CREATE TABLE IF NOT EXISTS compra_confiteria (
  id_compra_confiteria INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  compra_id       INTEGER NOT NULL REFERENCES compra(id_compra)          ON DELETE CASCADE,
  combo_id        INTEGER NOT NULL REFERENCES combo_confiteria(id_combo) ON DELETE RESTRICT,
  cantidad        INTEGER NOT NULL CHECK (cantidad > 0),
  precio_unitario NUMERIC(10,2) NOT NULL CHECK (precio_unitario >= 0),
  subtotal        NUMERIC(10,2) GENERATED ALWAYS AS (cantidad * precio_unitario) STORED,
  CONSTRAINT uniq_compra_combo UNIQUE (compra_id, combo_id)
);

-- ============ Índices extra para performance ============
CREATE INDEX IF NOT EXISTS idx_usuario_correo ON usuario(correo_electronico);
CREATE INDEX IF NOT EXISTS idx_usuario_nombre ON usuario(nombre_usuario);

CREATE INDEX IF NOT EXISTS idx_compra_usuario_fecha ON compra(usuario_id, fecha_hora_compra DESC);
CREATE INDEX IF NOT EXISTS idx_compra_fecha  ON compra(fecha_hora_compra);
CREATE INDEX IF NOT EXISTS idx_compra_estado ON compra(estado_compra);

CREATE INDEX IF NOT EXISTS idx_entrada_compra  ON entrada(compra_id);
CREATE INDEX IF NOT EXISTS idx_entrada_funcion ON entrada(funcion_id);
CREATE INDEX IF NOT EXISTS idx_entrada_asiento ON entrada(asiento_id);
CREATE INDEX IF NOT EXISTS idx_entrada_estado  ON entrada(estado_entrada);

CREATE INDEX IF NOT EXISTS idx_funcion_pelicula_fecha ON funcion(pelicula_id, fecha_hora_inicio);
CREATE INDEX IF NOT EXISTS idx_funcion_sala           ON funcion(sala_id);
CREATE INDEX IF NOT EXISTS idx_funcion_fecha          ON funcion(fecha_hora_inicio);
CREATE INDEX IF NOT EXISTS idx_funcion_estado         ON funcion(estado);

CREATE INDEX IF NOT EXISTS idx_asiento_sala ON asiento(sala_id);

CREATE INDEX IF NOT EXISTS idx_cc_compra ON compra_confiteria(compra_id);
CREATE INDEX IF NOT EXISTS idx_cc_combo  ON compra_confiteria(combo_id);

-- ============ Triggers / Funciones de negocio ============

-- Límite de 5 entradas por compra (INSERT y UPDATE)
CREATE OR REPLACE FUNCTION fn_validar_max_entradas()
RETURNS TRIGGER AS $$
DECLARE v_conteo INTEGER;
BEGIN
  IF TG_OP = 'INSERT' THEN
    SELECT COUNT(*) INTO v_conteo FROM entrada WHERE compra_id = NEW.compra_id;
    IF v_conteo >= 5 THEN
      RAISE EXCEPTION 'Una compra no puede exceder 5 entradas (compra_id=%)', NEW.compra_id;
    END IF;
  ELSIF TG_OP = 'UPDATE' THEN
    IF NEW.compra_id <> OLD.compra_id THEN
      SELECT COUNT(*) INTO v_conteo FROM entrada WHERE compra_id = NEW.compra_id;
      IF v_conteo >= 5 THEN
        RAISE EXCEPTION 'Una compra no puede exceder 5 entradas (compra_id=%)', NEW.compra_id;
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_max_5_entradas ON entrada;
CREATE TRIGGER trg_max_5_entradas
BEFORE INSERT OR UPDATE ON entrada
FOR EACH ROW EXECUTE FUNCTION fn_validar_max_entradas();

COMMIT;
